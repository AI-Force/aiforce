# AUTOGENERATED! DO NOT EDIT! File to edit: tensorflow-tfrecord_builder.ipynb (unless otherwise specified).

__all__ = ['logger', 'create_tfrecord_entry', 'create_tfrecord_file', 'int64_feature', 'int64_list_feature',
           'bytes_feature', 'bytes_list_feature', 'float_list_feature', 'configure_logging']

# Cell

import logging
import logging.handlers
import argparse
import io
import sys
import tensorflow as tf
from os import environ
from os.path import join
from ..core import Type, infer_type
from ..via import converter as via_converter
from ..image.pillow_tools import get_image_size
from mlcore import category_tools

# Cell

environ['TF_CPP_MIN_LOG_LEVEL'] = '2'    # Suppress TensorFlow logging (1)

logger = logging.getLogger(__name__)

# Cell


def create_tfrecord_entry(source_path, categories, annotation):
    file_name = annotation['filename']
    with tf.io.gfile.GFile(join(source_path, file_name), 'rb') as fid:
        encoded_jpg = fid.read()
    width, height = get_image_size(io.BytesIO(encoded_jpg))

    file_name = file_name.encode('utf8')
    image_format = b'jpg'
    xmins = []
    xmaxs = []
    ymins = []
    ymaxs = []
    classes_text = []
    classes = []

    regions = annotation['regions']
    for index, region in regions.items():
        shape_attributes = region['shape_attributes']
        region_attributes = region['region_attributes']

        x = shape_attributes["x"]
        y = shape_attributes["y"]
        max_x = x + shape_attributes["width"]
        max_y = y + shape_attributes["height"]
        category = region_attributes['category']

        xmins.append(x / width)
        xmaxs.append(max_x / width)
        ymins.append(y / height)
        ymaxs.append(max_y / height)
        classes_text.append(category.encode('utf8'))
        classes.append(categories.index(category))

    tf_example = tf.train.Example(features=tf.train.Features(feature={
        'image/height': int64_feature(height),
        'image/width': int64_feature(width),
        'image/filename': bytes_feature(file_name),
        'image/source_id': bytes_feature(file_name),
        'image/encoded': bytes_feature(encoded_jpg),
        'image/format': bytes_feature(image_format),
        'image/object/bbox/xmin': float_list_feature(xmins),
        'image/object/bbox/xmax': float_list_feature(xmaxs),
        'image/object/bbox/ymin': float_list_feature(ymins),
        'image/object/bbox/ymax': float_list_feature(ymaxs),
        'image/object/class/text': bytes_list_feature(classes_text),
        'image/object/class/label': int64_list_feature(classes),
    }))
    return tf_example

# Cell


def create_tfrecord_file(output_path, source_path, categories, annotation_file_path):

    writer = tf.io.TFRecordWriter(output_path)
    annotations = via_converter.read_annotations(annotation_file_path)
    for annotation in annotations.values():
        tf_example = create_tfrecord_entry(source_path, categories, annotation)
        writer.write(tf_example.SerializeToString())
    writer.close()
    logger.info('Successfully created the TFRecord file: {}'.format(output_path))

# Cell


def int64_feature(value):
    return tf.train.Feature(int64_list=tf.train.Int64List(value=[value]))


def int64_list_feature(value):
    return tf.train.Feature(int64_list=tf.train.Int64List(value=value))


def bytes_feature(value):
    return tf.train.Feature(bytes_list=tf.train.BytesList(value=[value]))


def bytes_list_feature(value):
    return tf.train.Feature(bytes_list=tf.train.BytesList(value=value))


def float_list_feature(value):
    return tf.train.Feature(float_list=tf.train.FloatList(value=value))

# Cell


def configure_logging(logging_level=logging.INFO):
    """
    Configures logging for the system.

    :param logging_level: The logging level to use.
    """
    logger.setLevel(logging_level)

    handler = logging.StreamHandler(sys.stdout)
    handler.setLevel(logging_level)

    logger.addHandler(handler)

# Cell


if __name__ == '__main__' and '__file__' in globals():
    configure_logging()

    parser = argparse.ArgumentParser()
    parser.add_argument("-o",
                        "--output",
                        help="Path of output TFRecord (.record) file.",
                        type=str)
    parser.add_argument("-s",
                        "--source",
                        help="The path to the data-set source files.",
                        type=str)
    parser.add_argument("-c",
                        "--categories",
                        help="The path to the data-set categories file.",
                        type=str)
    parser.add_argument("-a",
                        "--annotation",
                        help="The path to the data-set annotation file, the data-set is build from.",
                        type=str)
    parser.add_argument("-t",
                        "--type",
                        help="The type of the data-set, if not explicitly set try to infer from categories file path.",
                        choices=list(Type),
                        type=Type,
                        default=None)
    args = parser.parse_args()

    category_file_path = args.categories
    data_set_type = args.type
    # try to infer the data-set type if not explicitly set
    if data_set_type is None:
        try:
            data_set_type = infer_type(category_file_path)
        except ValueError as e:
            logger.error(e)
            sys.exit(1)

    categories = category_tools.read_categories(category_file_path, data_set_type)

    create_tfrecord_file(args.output, args.source, categories, args.annotation)

    logger.info('FINISHED!!!')
