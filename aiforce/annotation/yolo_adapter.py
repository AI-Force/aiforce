# AUTOGENERATED! DO NOT EDIT! File to edit: annotation-yolo_adapter.ipynb (unless otherwise specified).

__all__ = ['SEPARATION_FILE_NAME_HEADERS', 'DEFAULT_IMAGES_FOLDER', 'DEFAULT_IMAGE_ANNOTATIONS_FOLDER', 'logger',
           'YOLOAnnotationAdapter']


# Cell
import csv
import logging
import shutil
import yaml
from os.path import join, splitext, basename, isfile
from ..core import assign_arg_prefix
from ..io.core import scan_files, create_folder
from ..image.opencv_tools import get_image_size
from .core import Annotation, AnnotationAdapter, Region, RegionShape, SubsetType, normalize_value, denormalize_value


# Cell
DEFAULT_INDEX_FILE = 'index.yaml'
DEFAULT_IMAGES_FOLDER = 'images'
DEFAULT_IMAGE_ANNOTATIONS_FOLDER = 'labels'

ANNOTATION_CENTER_SIZE = "center_size"
ANNOTATION_MIN_MAX = "min_max"
ANNOTATION_FORMATS = [ANNOTATION_CENTER_SIZE, ANNOTATION_MIN_MAX]

SEPARATION_FILE_NAME = "file_name"
SEPARATION_SUBSET_TYPE = "subset_type"
SEPARATION_STRATEGIES = [SEPARATION_FILE_NAME, SEPARATION_SUBSET_TYPE]

SEPARATION_FILE_NAME_HEADERS = ['class_number', 'c_x', 'c_y', 'width', 'height']

# Cell
logger = logging.getLogger(__name__)


# Cell
class YOLOAnnotationAdapter(AnnotationAdapter):
    """
    Adapter to read and write annotations in the YOLO format.
    """

    def __init__(self, path, categories_file_name=None, images_folder_name=None, annotations_folder_name=None,
                 annotation_format=ANNOTATION_CENTER_SIZE, normalize_values=False,
                 separation_strategy=SEPARATION_FILE_NAME):
        """
        YOLO Adapter to read and write annotations.
        `path`: the folder containing the annotations
        `categories_file_name`: the name of the categories file
        `images_folder_name`: the name of the folder containing the image files
        `annotations_folder_name`: the name of the folder containing the mage annotations
        """
        super().__init__(path, categories_file_name)

        self.categories_file_name = DEFAULT_INDEX_FILE if categories_file_name is None else categories_file_name
        self.annotation_format = annotation_format
        self.separation_strategy = separation_strategy
        self.normalize_values = normalize_values

        if images_folder_name is None:
            self.images_folder_name = DEFAULT_IMAGES_FOLDER
        else:
            self.images_folder_name = images_folder_name

        if annotations_folder_name is None:
            self.annotations_folder_name = DEFAULT_IMAGE_ANNOTATIONS_FOLDER
        else:
            self.annotations_folder_name = annotations_folder_name

    @classmethod
    def argparse(cls, prefix=None):
        """
        Returns the argument parser containing argument definition for command line use.
        `prefix`: a parameter prefix to set, if needed
        return: the argument parser
        """
        parser = super(YOLOAnnotationAdapter, cls).argparse(prefix=prefix)
        parser.add_argument(assign_arg_prefix('--images_folder_name', prefix),
                            dest="images_folder_name",
                            help="The name of the folder containing the image files.",
                            default=None)
        parser.add_argument(assign_arg_prefix('--annotations_folder_name', prefix),
                            dest="annotations_folder_name",
                            help="The name of the folder containing the image annotations.",
                            default=None)
        parser.add_argument(assign_arg_prefix('--annotation_format', prefix),
                            dest="annotation_format",
                            type=str,
                            choices=ANNOTATION_FORMATS,
                            help="The annotation format, default to center_size.",
                            default=ANNOTATION_FORMATS[0])
        parser.add_argument(assign_arg_prefix('--normalize_values', prefix),
                            dest="normalize_values",
                            help="Normalize the values between 0 and 1.",
                            action="store_true",
                            default=False)
        parser.add_argument(assign_arg_prefix('--separation_strategy', prefix),
                            dest="separation_strategy",
                            type=str,
                            choices=SEPARATION_STRATEGIES,
                            help="The annotation separation strategy, default to separate by file name.",
                            default=SEPARATION_STRATEGIES[0])
        return parser

    def read_annotations(self, categories, subset_type=SubsetType.TRAINVAL):
        """
        Reads YOLO annotations.
        `categories`: the categories as list
        `subset_type`: the subset type to read
        return: the annotations as dictionary
        """
        annotations_path = join(self.path, self.annotations_folder_name, str(subset_type))
        images_path = join(self.path, self.images_folder_name, str(subset_type))

        logger.info('Read images from {}'.format(images_path))
        logger.info('Read annotations from {}'.format(annotations_path))

        if self.separation_strategy == SEPARATION_FILE_NAME:
            annotations, skipped_annotations = self._read_annotations_by_file_name_separation(
                annotations_path, images_path, categories)
        else:
            annotations, skipped_annotations = self._read_annotations_by_sub_type_separation(
                subset_type, annotations_path, images_path, categories)

        logger.info('Finished read annotations')
        logger.info('Annotations read: {}'.format(len(annotations)))
        if skipped_annotations:
            logger.info('Annotations skipped: {}'.format(len(skipped_annotations)))

        return annotations

    def read_categories(self):
        """
        Read categories.
        return: a list of category names
        """
        path = join(self.path, self.categories_file_name)
        with open(path, mode="rt", encoding="utf-8") as file:
            logger.info('Read index file from {}'.format(path))
            index_data = yaml.safe_load(file)
            return index_data["names"]

    def write_annotations(self, annotations, categories, subset_type=SubsetType.TRAINVAL):
        """
        Writes YOLO annotations to the annotations folder and copy the corresponding source files.
        `annotations`: the annotations as dictionary
        `categories`: the categories as list
        `subset_type`: the subset type to write
        return: a list of written target file paths
        """
        annotations_path = create_folder(join(self.path, self.annotations_folder_name, str(subset_type)))
        images_path = create_folder(join(self.path, self.images_folder_name, str(subset_type)))

        logger.info('Write images to {}'.format(images_path))
        logger.info('Write annotations to {}'.format(annotations_path))

        if self.separation_strategy == SEPARATION_FILE_NAME:
            copied_files, skipped_annotations = self._write_annotations_by_file_name_separation(
                annotations, annotations_path, images_path, categories)
        else:
            copied_files, skipped_annotations = self._write_annotations_by_subset_type_separation(
                annotations, subset_type, annotations_path, images_path, categories)

        logger.info('Finished write annotations')
        logger.info('Annotations written: {}'.format(len(annotations) - len(skipped_annotations)))
        if skipped_annotations:
            logger.info('Annotations skipped: {}'.format(len(skipped_annotations)))
        return copied_files

    def write_categories(self, categories):
        """
        Write categories.
        `categories`: a list of category names
        """

        categories_str = map(lambda c: f"'{c}'", categories)
        index_data = [
            f"path: {self.path}",
            f"train: {join('images', str(SubsetType.TRAIN))}",
            f"val: {join('images', str(SubsetType.VAL))}",
            f"test: {join('images', str(SubsetType.TEST))}",
            f"nc: {len(categories)}",
            f"names: [{', '.join(categories_str)}]",
        ]
        target_folder = create_folder(self.path)
        path = join(target_folder, self.categories_file_name)
        with open(path, mode="wt", encoding="utf-8") as file:
            logger.info('Write index file to {}'.format(path))
            file.write('\n'.join(index_data) + '\n')

    @classmethod
    def _read_annotations_by_file_name_separation(cls, annotations_path, images_path, categories):
        annotations = {}
        skipped_annotations = []
        annotation_files = scan_files(annotations_path, file_extensions='.txt')
        categories_len = len(categories)

        for annotation_file in annotation_files:
            with open(annotation_file, newline='') as csv_file:
                file_name, _ = splitext(basename(annotation_file))
                image_name = f"{file_name}.jpg"
                file_path = join(images_path, image_name)

                if not isfile(file_path):
                    logger.warning("{}: Source file not found, skip annotation.".format(file_path))
                    skipped_annotations.append(file_path)
                    continue

                if image_name not in annotations:
                    annotations[image_name] = Annotation(annotation_id=image_name, file_path=file_path)

                annotation = annotations[image_name]

                reader = csv.DictReader(csv_file, fieldnames=SEPARATION_FILE_NAME_HEADERS, delimiter=' ')
                _, image_width, image_height = get_image_size(file_path)
                for row in reader:
                    c_x = float(row["c_x"])
                    c_y = float(row["c_y"])
                    width = float(row["width"])
                    height = float(row["height"])
                    class_number = int(row["class_number"])
                    # denormalize bounding box
                    x_min = denormalize_value(c_x - (width / 2), image_width)
                    y_min = denormalize_value(c_y - (height / 2), image_height)
                    x_max = x_min + denormalize_value(width, image_width)
                    y_max = y_min + denormalize_value(height, image_height)
                    points_x = [x_min, x_max]
                    points_y = [y_min, y_max]

                    labels = [categories[class_number]] if class_number < categories_len else []
                    if not labels:
                        logger.warning("{}: Class number exceeds categories, set label as empty.".format(
                            annotation_file
                        ))
                    region = Region(shape=RegionShape.RECTANGLE, points_x=points_x, points_y=points_y, labels=labels)
                    annotation.regions.append(region)
        return annotations, skipped_annotations

    @classmethod
    def _read_annotations_by_sub_type_separation(cls, subset_type, annotations_path, images_path, categories):
        annotations = {}
        skipped_annotations = []
        categories_len = len(categories)
        annotation_file = join(annotations_path, f"{subset_type}.txt")
        with open(annotation_file, newline='') as txt_file:
            for line in txt_file:
                image_name, *annotation_list = line.strip().split(' ')
                file_path = join(images_path, image_name)

                if not isfile(file_path):
                    logger.warning("{}: Source file not found, skip annotation.".format(file_path))
                    skipped_annotations.append(file_path)
                    continue

                if image_name not in annotations:
                    annotations[image_name] = Annotation(annotation_id=image_name, file_path=file_path)

                annotation = annotations[image_name]

                for index, anno in enumerate(annotation_list):
                    [x_min, y_min, x_max, y_max, class_number] = map(int, anno.split(','))
                    points_x = [x_min, x_max]
                    points_y = [y_min, y_max]

                    labels = [categories[class_number]] if class_number < categories_len else []
                    if not labels:
                        msg = "{} - annotation {}: Class number exceeds categories, set label as empty.".format(
                            image_name, index
                        )
                        logger.warning(msg)
                    region = Region(shape=RegionShape.RECTANGLE, points_x=points_x, points_y=points_y, labels=labels)
                    annotation.regions.append(region)
        return annotations, skipped_annotations

    @classmethod
    def _write_annotations_by_file_name_separation(cls, annotations, annotations_path, images_path, categories):
        copied_files = []
        skipped_annotations = []

        for annotation in annotations.values():
            image_name = basename(annotation.file_path)
            file_name, _ = splitext(image_name)
            annotations_file = join(annotations_path, f'{file_name}.txt')
            target_file = join(images_path, image_name)

            if not isfile(annotation.file_path):
                logger.warning("{}: Source file not found, skip annotation.".format(annotation.file_path))
                skipped_annotations.append(annotation.file_path)
                continue
            if isfile(target_file):
                logger.warning("{}: Target file already exist, skip annotation.".format(annotation.file_path))
                skipped_annotations.append(annotation.file_path)
                continue

            _, image_width, image_height = get_image_size(annotation.file_path)
            rows = []
            skipped_regions = []
            for index, region in enumerate(annotation.regions):
                if region.shape != RegionShape.RECTANGLE:
                    logger.warning('Unsupported shape {}, skip region {} at path: {}'.format(region.shape,
                                                                                             index,
                                                                                             annotations_file))
                    skipped_regions.append(region)
                    continue

                x_min, x_max = region.points_x
                y_min, y_max = region.points_y
                width = x_max - x_min
                height = y_max - y_min
                # normalize bounding box
                c_x = normalize_value(x_min + width / 2, image_width)
                c_y = normalize_value(y_min + height / 2, image_height)
                width = normalize_value(width, image_width)
                height = normalize_value(height, image_height)
                label = region.labels[0] if len(region.labels) else ''
                try:
                    class_number = categories.index(label)
                except ValueError:
                    logger.warning('Unsupported label {}, skip region {} at path: {}'.format(label,
                                                                                             index,
                                                                                             annotations_file))
                    skipped_regions.append(region)
                    continue
                rows.append(dict(zip(SEPARATION_FILE_NAME_HEADERS, [class_number, c_x, c_y, width, height])))

            if len(skipped_regions) == len(annotation.regions):
                logger.warning("{}: All regions skipped, skip annotation.".format(annotation.file_path))
                skipped_annotations.append(annotation.file_path)
                continue

            # write the annotations
            with open(annotations_file, 'w', newline='') as csv_file:
                writer = csv.DictWriter(csv_file, fieldnames=SEPARATION_FILE_NAME_HEADERS, delimiter=' ')
                writer.writerows(rows)

            # copy the file
            shutil.copy2(annotation.file_path, target_file)
            copied_files.append(target_file)
        return copied_files, skipped_annotations

    @classmethod
    def _write_annotations_by_subset_type_separation(cls, annotations, subset_type, annotations_path, images_path,
                                                     categories):
        copied_files = []
        skipped_annotations = []
        annotation_file = join(annotations_path, f"{subset_type}.txt")
        with open(annotation_file, "w", newline='') as txt_file:
            for annotation in annotations.values():
                image_name = basename(annotation.file_path)
                target_file = join(images_path, image_name)

                if not isfile(annotation.file_path):
                    logger.warning("{}: Source file not found, skip annotation.".format(annotation.file_path))
                    skipped_annotations.append(annotation.file_path)
                    continue
                if isfile(target_file):
                    logger.warning("{}: Target file already exist, skip annotation.".format(annotation.file_path))
                    skipped_annotations.append(annotation.file_path)
                    continue

                rows = []
                skipped_regions = []
                for index, region in enumerate(annotation.regions):
                    if region.shape != RegionShape.RECTANGLE:
                        logger.warning('Unsupported shape {}, skip region {} at path: {}'.format(region.shape,
                                                                                                 index,
                                                                                                 target_file))
                        skipped_regions.append(region)
                        continue

                    x_min, x_max = region.points_x
                    y_min, y_max = region.points_y
                    label = region.labels[0] if len(region.labels) else ''
                    try:
                        class_number = categories.index(label)
                    except ValueError:
                        logger.warning('Unsupported label {}, skip region {} at path: {}'.format(label,
                                                                                                 index,
                                                                                                 target_file))
                        skipped_regions.append(region)
                        continue
                    rows.append(','.join(map(str, [x_min, y_min, x_max, y_max, class_number])))

                if len(skipped_regions) == len(annotation.regions):
                    logger.warning("{}: All regions skipped, skip annotation.".format(annotation.file_path))
                    skipped_annotations.append(annotation.file_path)
                    continue
                txt_file.write(f"{' '.join([image_name] + rows)}\n")

                # copy the file
                shutil.copy2(annotation.file_path, target_file)
                copied_files.append(target_file)
        return copied_files, skipped_annotations
